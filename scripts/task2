#!/usr/bin/env python3

import accelnet_challenge_sdu as sdu
import rospy
import tf2_ros
import geometry_msgs.msg
import sensor_msgs.msg
import std_msgs.msg
import threading
import numpy as np
import queue
import quaternion



NEEDLE_RADIUS = 0.1018


def compute_pose_needle_grasp(phi):
    y = NEEDLE_RADIUS * np.sin(phi)
    x = -NEEDLE_RADIUS * np.cos(phi)
    z = 0
    return sdu.Pose([x, y, z]) @ sdu.Pose.Rz(-phi) @ sdu.Pose.Rx(np.pi) @ sdu.Pose.Rz(-np.pi/2)


# def pose_suture_frame(ident, tf_buffer):
#     sutur_center_frame = Frame()
#     entry_p = getEntryFrame(entry_id).p
#     exit_p = getExitFrame(entry_id).p

#     z_offset = 0.08

#     sutur_center_frame.p = (entry_p + exit_p)/2 + Vector(0, 0, z_offset)
#     sutur_center_frame.M = Rotation(-1, 0, 0,
#                                     0, 0, -1,
#                                     0, -1, 0)
#     return sutur_center_frame


class PSM:
    def __init__(self, arm):
        self.base_link_name = f'psm{arm}/baselink'

        self.pub_ee_servo_cp = rospy.Publisher(f'/CRTK/psm{arm}/servo_cp', geometry_msgs.msg.PoseStamped, queue_size=1)
        self.pub_jaw_servo_jp = rospy.Publisher(f'/CRTK/psm{arm}/jaw/servo_jp', sensor_msgs.msg.JointState, queue_size=1)

        self.lock_pose_ee_desired = threading.Lock()
        self.lock_msg_measured_cp = threading.Lock()

        self.pose_ee_desired = None
        self.msg_measured_cp = None

        self.subs = [
            rospy.Subscriber(f'/CRTK/psm{arm}/measured_cp', geometry_msgs.msg.PoseStamped, self._set_measured_cp, queue_size=1)
        ]

        self.pose_world_base = sdu.Pose.from_msg(rospy.wait_for_message(f'/CRTK/psm{arm}/T_b_w', geometry_msgs.msg.PoseStamped).pose)
        self.pose_base_world = self.pose_world_base.inverse()


    def _set_measured_cp(self, msg):
        with self.lock_msg_measured_cp:
            self.msg_measured_cp = msg

    def pose_ee_current(self):
        with self.lock_msg_measured_cp:
            msg = self.msg_measured_cp
        return sdu.Pose.from_msg(msg.pose)

    # def servo_ee(self, pose):
    #     msg = geometry_msgs.msg.PoseStamped()
    #     msg.header.frame_id = self.base_link_name
    #     msg.header.stamp = rospy.Time.now()
    #     msg.pose = pose.to_msg('geometry_msgs/Pose')
    #     self.pub_ee_servo_cp.publish(msg)

    def feedback_control_loop(self):
        rate = rospy.Rate(120)
        dt = 1 / 120
        Kp = np.diag([1.1, 1.1, 1.1])
        Kd = np.diag([0.0, 0.0, 0.0])
        e_prev = np.zeros(3)

        while not rospy.is_shutdown():
            with self.lock_pose_ee_desired:
                pose_ee_desired = self.pose_ee_desired

            if pose_ee_desired is None:
                rate.sleep()
                continue

            # PD control on position values
            pose_ee_current = self.pose_ee_current()
            # e = (pose_ee_desired @ pose_ee_current.inverse()).p
            e = pose_ee_desired.p - pose_ee_current.p
            # d = (e - e_prev) / dt
            u = Kp @ e #+ Kd @ d
            # e_prev = e

            pose = sdu.Pose(pose_ee_desired.p + u, pose_ee_desired.q)
            # pose = pose_ee_desired

            msg = geometry_msgs.msg.PoseStamped()
            msg.header.stamp = rospy.Time.now()
            msg.header.frame_id = self.base_link_name
            msg.pose = pose.to_msg('geometry_msgs/Pose')
            self.pub_ee_servo_cp.publish(msg)

            rate.sleep()

    def servo_ee_interpolate(self, pose1, n):
        with self.lock_pose_ee_desired:
            pose_ee_desired = self.pose_ee_desired

        pose0 = self.pose_ee_current() if pose_ee_desired is None else pose_ee_desired
        ds = 1 / n
        dp = (pose1.p - pose0.p) / n

        msg = geometry_msgs.msg.PoseStamped()
        msg.header.frame_id = self.base_link_name

        rate = rospy.Rate(120)

        for i in range(1, n+1):
            if rospy.is_shutdown():
                break

            pose = sdu.Pose(
                pose0.p + i * dp,
                quaternion.slerp(pose0.q, pose1.q, 0, 1, i*ds)
            )

            with self.lock_pose_ee_desired:
                self.pose_ee_desired = pose

            rate.sleep()

    def servo_jaw(self, opening_angle):
        msg = sensor_msgs.msg.JointState()
        msg.position = [opening_angle]
        self.pub_jaw_servo_jp.publish(msg)


class ECM:
    def __init__(self):
        self.base_link_name = 'world'

        self.pub_servo_jp = rospy.Publisher('/CRTK/ecm/servo_jp', sensor_msgs.msg.JointState, queue_size=1)

        self.msg_measured_cp = None
        self.subs = [
            rospy.Subscriber('/CRTK/ecm/measured_cp', geometry_msgs.msg.PoseStamped, self._set_measured_cp, queue_size=1)
        ]

    def _set_measured_cp(self, msg):
        # Should be OK without mutex as long as it's assigning a single ref.
        self.msg_measured_cp = msg

    def pose_ee_current(self):
        return sdu.Pose.from_msg(self.msg_measured_cp.pose)

    def servo_joint(self, joint_values):
        msg = sensor_msgs.msg.JointState()
        msg.header.stamp = rospy.Time.now()
        msg.position = joint_values
        self.pub_servo_jp.publish(msg)


rospy.init_node('task2')

pub_goal = rospy.Publisher('/sdu/psm2/goal', geometry_msgs.msg.PoseStamped, queue_size=1)

pub_result = rospy.Publisher('completion_report', std_msgs.msg.Bool, queue_size=1)

tf_buffer = tf2_ros.Buffer()
tf_listener = tf2_ros.TransformListener(tf_buffer)

psm2 = PSM(2)
ecm = ECM()


psm1_control_thread = threading.Thread(target=psm2.feedback_control_loop)
psm1_control_thread.start()

rospy.sleep(1)
ecm.servo_joint([0, 0.2, -0.2, 0])
rospy.sleep(1)
psm2.servo_jaw(np.radians(30))
rospy.sleep(1)

pose_world_needle = sdu.Pose.from_msg(tf_buffer.lookup_transform('world', 'Needle', time=rospy.Time(), timeout=rospy.Duration(2)).transform)

pose_needle_grasp = compute_pose_needle_grasp(np.radians(10)) @ sdu.Pose([0, 0, -0.2])
pose_world_grasp = pose_world_needle @ pose_needle_grasp
pose_psm2base_grasp = psm2.pose_base_world @ pose_world_grasp

msg = geometry_msgs.msg.PoseStamped()
msg.header.frame_id = 'psm2/baselink'
msg.header.stamp = rospy.Time.now()
msg.pose = pose_psm2base_grasp.to_msg('geometry_msgs/Pose')
pub_goal.publish(msg)

rospy.loginfo("Move above grasp point")
psm2.servo_ee_interpolate(pose_psm2base_grasp, 3*120)
rospy.sleep(1)

pose_needle_grasp = compute_pose_needle_grasp(np.radians(10)) @ sdu.Pose([0, 0, 0.03])
pose_world_grasp = pose_world_needle @ pose_needle_grasp
pose_psm2base_grasp = psm2.pose_base_world @ pose_world_grasp

msg = geometry_msgs.msg.PoseStamped()
msg.header.frame_id = 'psm2/baselink'
msg.header.stamp = rospy.Time.now()
msg.pose = pose_psm2base_grasp.to_msg('geometry_msgs/Pose')
pub_goal.publish(msg)

rospy.loginfo("Move to grasp point")
psm2.servo_ee_interpolate(pose_psm2base_grasp, 120)
rospy.sleep(1)


rospy.loginfo("Close grasper jaws")
psm2.servo_jaw(0)
rospy.sleep(1)


pose_needle_grasp = compute_pose_needle_grasp(np.radians(10)) @ sdu.Pose([0, 0, -0.2])
pose_world_grasp = pose_world_needle @ pose_needle_grasp
pose_psm2base_grasp = psm2.pose_base_world @ pose_world_grasp

msg = geometry_msgs.msg.PoseStamped()
msg.header.frame_id = 'psm2/baselink'
msg.header.stamp = rospy.Time.now()
msg.pose = pose_psm2base_grasp.to_msg('geometry_msgs/Pose')
pub_goal.publish(msg)

rospy.loginfo("Move up")
psm2.servo_ee_interpolate(pose_psm2base_grasp, 2*120)
rospy.sleep(1)

rospy.spin()
psm1_control_thread.join()
